---
sidebar_position: 1
sidebar_label: Global ID
description: Use the Relay Global ID specification to encode the type and ID of an object in a single string.
keywords:
  - hasura
  - relay
  - graphql
  - global id
---

# Hasura Global ID

## Introduction

You can use Hasura's Global ID to provide options for GraphQL clients to elegantly handle caching and data refetching in
a standardized way.

The GraphQL schema created by Hasura offers a consistent method for fetching an object using a Global ID. Additionally,
the schema provides a standardized approach in the response to present these Global IDs. This helps ensure a uniform and
predictable way of handling object retrieval and identification.

As the example below shows, the `user` object type has a field `user_id` that uniquely identifies a user. The Global ID
for the `user` object type will be generated using the `user_id` field:

```graphql
{
  user_by_id(user_id: 1) {
    id // Global ID
    user_id
    name
  }
  node(id: "eyJ2ZXJzaW9uIjoxLCJ0eXBlbmFtZSI6IlVzZXIiLCJpZCI6eyJ1c2VyX2lkIjoxfX0=") {
    id
    ... on User {
      name
    }
  }

}
```

## Open DDS object reference schema

To set up the JSON structure that allows creating a Global ID for an `Object` type, you'll need to define which fields
within the `Object` type should be used to uniquely identify each individual object of that type. This helps ensure that
each object can be distinguished accurately when using Global IDs.

The following is the JSON schema of the `Object` type.

```json
{
  "description": "Definition of a user-defined GDS object type.",
  "type": "object",
  "required": ["fields", "kind", "name"],
  "properties": {
    "fields": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/FieldDefinition"
      }
    },
    "globalID": {
      "type": ["array", "null"],
      "items": {
        "$ref": "#/definitions/FieldName"
      }
    },
    "kind": {
      "type": "string",
      "enum": ["objectType"]
    },
    "name": {
      "$ref": "#/definitions/TypeName"
    }
  }
}
```

### JSON schema of the related types

Our reference schema uses the following related types:

1. `FieldDefinition`

```json
{
  "description": "The definition of a field in a user-defined object type.",
  "type": "object",
  "required": ["name", "type"],
  "properties": {
    "name": {
      "$ref": "#/definitions/FieldName"
    },
    "type": {
      "$ref": "#/definitions/Type"
    }
  }
}
```

2. `FieldName`

```json
{
  "description": "The name of a field in a user-defined object type.",
  "type": "string"
}
```

3. `Type`

```json
{
  "description": "Types track the valid representations of values as JSON",
  "oneOf": [
    {
      "description": "A named type",
      "type": "object",
      "required": ["name", "type"],
      "properties": {
        "name": {
          "description": "The name can refer to a primitive type or a scalar type",
          "type": "string"
        },
        "type": {
          "type": "string",
          "enum": ["named"]
        }
      }
    },
    {
      "description": "A nullable type",
      "type": "object",
      "required": ["type", "underlying_type"],
      "properties": {
        "type": {
          "type": "string",
          "enum": ["nullable"]
        },
        "underlying_type": {
          "description": "The type of the non-null inhabitants of this type",
          "allOf": [
            {
              "$ref": "#/definitions/Type"
            }
          ]
        }
      }
    },
    {
      "description": "An array type",
      "type": "object",
      "required": ["element_type", "type"],
      "properties": {
        "element_type": {
          "description": "The type of the elements of the array",
          "allOf": [
            {
              "$ref": "#/definitions/Type"
            }
          ]
        },
        "type": {
          "type": "string",
          "enum": ["array"]
        }
      }
    }
  ]
}
```

## Example

Let's consider the following `article` object and let's assume the `article_id` field uniquely identifies an article:

```json
{
  "kind": "objectType",
  "name": "article",
  "fields": [
    {
      "name": "article_id",
      "type": "Int"
    },
    {
      "name": "title",
      "type": "String"
    },
    {
      "name": "author_id",
      "type": "Int"
    }
  ]
}
```

We need to add the `article_id` field in the `globalID`.

```json
{
  "kind": "objectType",
  "name": "article",
  "fields": [
    {
      "name": "article_id",
      "type": "Int"
    },
    {
      "name": "title",
      "type": "String"
    },
    {
      "name": "author_id",
      "type": "Int"
    }
  ],
  // highlight-next-line
  "globalID": ["article_id"]
}
```

Next, we need to choose the model that implements the `article` object type to be the Global ID source for the object
type `article`. This can be done by adding `globalIDSource: true` in the model's definition:

```json
{
  "kind": "model",
  "name": "Articles",
  "dataType": "article",
  // highlight-next-line
  "globalIDSource": true
}
```

:::info Consideration for `id` fields and multiple models

For an object type to generate a Global ID, it should not have any field named `id`, because it will be generated
automatically.

Additionally, multiple models can implement the same object type, **but only one model out of this selection can be the
Global ID source of the object type.**

:::

With the above changes, the following GraphQL schema will be generated:

```graphql
interface Node {
  id: ID!
}

type Articles implements Node {
  article_id: Int!
  title: String!
}
```
